<?php

/**
 * @file
 * Module implementing EVA extra field and views display
 */

use Drupal\views\Views;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Component\Utility\Xss;

/**
 * Implements hook_entity_extra_field_info() to add the view fields to relevant entities
 */
function eva_entity_extra_field_info() {
  $extra = array();
  $views = eva_get_views();

  foreach ($views as $entity => $data) {
    foreach ($data as $view) {
      $bundles = $view['bundles'];
      foreach ($bundles as $bundle) {
        $extra[$entity][$bundle]['display'][$view['name'] . '_' . $view['display']] = array(
          'label' => (empty($view['title'])) ? $view['name'] : $view['title'], 
          'description' => $view['title'], 
          'weight' => 10,
        );
        // Provide a separate extra field for the exposed form if there is any.
        if ($view['exposed form']) {
          $extra[$entity][$bundle]['display'][$view['name'] . '_' . $view['display'] . '_' . 'form'] = array(
            'label' => ((empty($view['title'])) ? $view['name'] : $view['title']) . ' (' . t('Exposed form') . ')', 
            'description' => t('The exposed filter form of the view.'),
            'weight' => 9,
          );
        }
      }
    }
  }

  return $extra;
}


/**
 * Get a list of views and displays attached to speficic entities.
 *
 * This function will cache its results into the views cache, so it gets
 * cleared by Views appropriately.
 *
 * @param $type
 *   The entity type we want to retrieve views for. If NULL is
 *   specified, views for all entity types will be returned.
 * @param $reset
 *   Force a rebuild of the data.
 * @return
 *   An array of view name/display name values, or an empty array().
 */
function eva_get_views($type = NULL, $reset = FALSE) {
  // Build and cache the data, both in the DB and statically.
  $views = \Drupal\views\Views::getApplicableViews('uses_hook_entity_view');

  foreach ($views as $data) {
    list($view_name, $display_id) = $data;
    $view = Views::getView($view_name);

    // Initialize handlers, to determine if the view uses exposed filters.
    $view->initHandlers();
    $display = $view->displayHandlers->get($display_id);

    $view_entity = $display->getOption('entity_type');
    $used_views[$view_entity][] = array(
      'name' => $view_name,
      'id' => $view->storage->get('id'),
      'title' => 'EVA: ' . $view->storage->get('label') . ' - ' . $view->storage->getDisplay($display_id)['display_title'],
      'display' => $display_id,
      'bundles' => $display->getOption('bundles'),
      'exposed form' => $display->usesExposed(),
      'exposed form split' => $display->getOption('exposed_form_as_field'),
    );
    $view->destroy();
  }
  // Now spit back the data.
  if (isset($type) & isset($used_views)) {
    return isset($used_views[$type]) ? $used_views[$type] : array();
  }
  else {
    return isset($used_views) ? $used_views : array();
  }
}

/**
 * implement hook_entity_view_alter()
 */
function eva_entity_view_alter(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  $type = $entity->getEntityTypeId();
  $views = eva_get_views($type);

  foreach ($views as $info) {
    $longname = $info['name'] .'_'. $info['display'];

    if ($display->getComponent($longname)) {
      if ($view = Views::getView($info['name'])) {
        $view->setDisplay($info['display']);
        if ($view->access($info['display'])) {
          $view->current_entity = $entity;

          // exposed form
          if (isset($fields[$longname . '_form']) && $fields[$longname . '_form']['visible']) {
            $view->init_handlers();
            $exposed_form = $view->display_handler->get_plugin('exposed_form');

            $build[$longname . '_form'] = array(
              '#markup' => $exposed_form->render_exposed_form(TRUE),
            );
          }

          $element = $view->executeDisplay($info['display']);

          if (!empty($element)) {
            $build[$longname][] = $element;
          }
        }
      }
    }
  }
}


/**
 * Get view arguments array from string that contains tokens
 *
 * @param $string
 *   The token string defined by the view.
 * @param $type
 *   The token type.
 * @param $object
 *   The object being used for replacement data (typically a node).
 * @return
 *   An array of argument values.
 *
 * @todo: security?
 */
function eva_get_arguments_from_token_string($string, $type, $object) {
  $args = trim($string);
  if (empty($args)) {
    return array();
  }
  $args = token_replace($args, array($type => $object), array('sanitize' => FALSE));
  return explode('/', $args);
}

/**
 * Implements hook_modules_enabled().
 */
function eva_modules_enabled($modules) {
  // Reset the static cache in case any of the enabled modules
  // implement an eva view
  drupal_static_reset('eva_get_views');
  cache_clear_all('*', 'cache_views', TRUE);
}

/**
 * Implements hook_modules_disabled().
 */
function eva_modules_disabled($modules) {
  // Reset the static cache in case any of the disabled modules
  // implemented an eva view
  drupal_static_reset('eva_get_views');
  cache_clear_all('*', 'cache_views', TRUE);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function eva_form_views_ui_edit_form_alter(&$form, &$form_state, $form_id) {
  // Clear the field cache when views are saved. This will make sure newly
  // created EVA views and/or exposed filters will appear.
  $form['actions']['save']["#submit"][] = 'field_cache_clear';
}


/**
 * templating functions
 */
function template_preprocess_eva_display_entity_view(&$vars) {
  $view = $vars['view'];
  $display = $view->display_handler;
  $vars['title'] = $display->getOption('show_title') ? Xss::filterAdmin($view->getTitle()) : '';
  $vars['exposed_form_as_field'] = $display->getOption('exposed_form_as_field');
}
